#-------------------------------------------------------------------------------
# Name:        module1
# Purpose:
#
# Author:      Gaurav Singhal

# Created:     24/08/2012
# Copyright:   (c) Gaurav Singhal 2012
# Licence:     This work is licensed under the Creative Commons Attribution-NonCommercial 3.0 Unported License.
#              To view a copy of this license, visit http://creativecommons.org/licenses/by-nc/3.0/.
#-------------------------------------------------------------------------------

import sys
import random, math

'''
targetBed: Target coordinates of capture platform. We mostly use Agilent SureSelect V3 or V4.
pileupFile: pileup file generated by samtools. This pileup file should preferably have information only for bases within the target/capture coordinates.
'''
def surveyCoverage(pileupFile, targetBed):

    fh1 = open(targetBed, 'rU')
    data = fh1.readlines()
    fh1.close()
    locations = []
    for each in data:
        flds = each.split('\t')
        locations.append([flds[0].strip(), int(flds[1].strip()), int(flds[2].strip()), 0])

    loc_depth = {}
    fh2 = open(pileupFile, 'rU')
    for line in fh2:
        flds = line.split('\t')
        key = flds[0].strip() + '#' + flds[1].strip()
        loc_depth[key] = int(flds[3].strip())
    fh2.close()

    for z in range(len(locations)):

        numLoci = ((locations[z][2] - locations[z][1])/100)+1
##        print numLoci
        coverage = 0
        st = locations[z][1]+1
        end = locations[z][2]
        for i in range(numLoci):
            max_iters = 50
            while max_iters>0:
                max_iters-=1
                baseLoc = random.randint(st, end)

                key = locations[z][0] + '#' + str(baseLoc)
                if key in loc_depth:
                    break
            if key not in loc_depth:
                coverage+=0


            else:
                coverage+= loc_depth[key]
        meanCoverage = coverage/float(numLoci)
        locations[z][3] = meanCoverage

    return locations




def correlation(pileupFile1, targetBed1, pileupFile2, targetBed2, patient_name):

    one = surveyCoverage(pileupFile1, targetBed1)
    two = surveyCoverage(pileupFile2, targetBed2)
    outfileName = patient_name + 'meanCoverage.csv'
    fhout = open(outfileName, 'w')
    if len(one) != len(two):
        print 'Target Bed files are of unequal length. Please use the same target bed files. Exiting now !'
        sys.exit()
    else:
        for i in range(len(one)):
            outline = str(one[i][3]) + ','+ str(two[i][3]) + '\n'
            fhout.write(outline)
    fhout.close()


def coverageAnalysis(filein):
    fh = open(filein, 'rU')
    data = fh.readlines()
    fh.close()

    covs = []

    for line in data:
        flds = line.split(',')
        covs.append([float(flds[0].strip()), float(flds[1].strip())])

    sortedCovs = sorted(covs, reverse=True)

    print covs[:20]

    print '#################'

    print sortedCovs[:20]

    print len(sortedCovs)

    top95 = sortedCovs[:176354]

##    print top95[-31600:-31554]
    above20 = []
    for each in sortedCovs:
        if each[0] > 20.00:
            if each[1]>20.00:
                above20.append(each)

    print "# of targets with > 20x sequencing = ", len(above20), "which is ", str((float(len(above20))/len(sortedCovs))*100.00) ,'% of total targets'

    print above20[-10:]


def main():
##    pileupFile1 = sys.argv[1]
##    targetBed1 = sys.argv[2]
##    pileupFile2 = sys.argv[3]
##    targetBed2 = sys.argv[4]
##    patient_name = sys.argv[5]
##    correlation(pileupFile1, targetBed1, pileupFile2, targetBed2, patient_name)
    coverageAnalysis('PT_3_meanCoverage.csv')
if __name__ == '__main__':
    main()
