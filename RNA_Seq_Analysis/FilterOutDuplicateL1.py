'''
Created on Jul 25, 2010

@author: Gaurav
'''


'''
This script filters reads that map to multiple locations. Bowtie was used in such a way to 
report reads that map to multiple locations. -k 10 --best --strata were used. 
Thus a maximum of 10 best strata alignments would be reported per read.
Thus the input file has uniquely mapped reads and upto 10 best strata alignments for multiply aligned reads.

In other words, uniquely mapped reads have only one alignment, while those reads that map to multiple locations 
can have upto 10 alignments arranged in best to worst order, but all the alignments should belong to 
the best strata. i.e., if first 4 alignments are based on 1 mismatch and next 8 alignments are based on 
2 mismatches, then only first 4 alignments would be reported in best to worst order ( or most likely to least likely fashion).

 

This script parses this alignment output file and churns out 3 files. 

If the input file name is filename.map: 

1). then the first output file would be:

filename_k1.map            (k1 indicates that this output would be generated by Bowtie if '-k 1' was specified)

This file would contain all the uniquely mapped reads  and only one alignment (the very first alignment) for all the multiply aligned reads.


2). the second output file would be :
 
filename_rep.map

This file would contain only one alignment (the very first alignment) for all the multiply aligned reads.

3). the third output file would be :
 
filename_repAll.map

This file would contain all alignments for all the multiply aligned reads. Thus, if a read has 8 alignments, this file would have all 8 alignments listed in the same order as of input. 
These 8 alignments would be followed by the next set of multiple alignments.

'''

import sys
from sets import Set


'''
This method reports one overlap repeat instance. It is unlikely that one repeat overlaps two genes. However, 
if it finds another entry having the same repeat but with a different gene, then it adds it to the output list.

'''
def filterOutDup(overlapFile):
    overLapFile = open(overlapFile, 'rU')
    
    firstline = overLapFile.readline()
    
    entry = organizeRepeat(firstline)
    firstGene = organizeGene(firstline)
    
    
    repeats = Set([entry])
    genes = Set([firstGene])
    outname = overlapFile[:-4]+'_unique_rep_v2.bed'  

    uniqueOut = open(outname, 'w')
    
    uniqueOut.write(firstline)


        
    for line in overLapFile:
        repnum = organizeRepeat(line)
        gene = organizeGene(line)
        if repnum not in repeats:
            genes.add(gene)
            uniqueOut.write(line)
            repeats.add(repnum)
        elif gene not in genes:
            print 'found a repeat overlapping 2 genes'
            print line
            genes.add(gene)
            uniqueOut.write(line)
        
    uniqueOut.close()
            
            
def filterOutDupV3(overlapFile):
    overLapFile = open(overlapFile, 'rU')
    
    firstline = overLapFile.readline()
    
    entry = organizeRepeatGene(firstline)
    
    
    
    repGeneCombo = Set([entry])
    
    outname = overlapFile[:-4]+'_unique_rep_v3.bed'  # v3 means keeping a set of repeat number and 
                                                     # gene name. So, a repeat number and gene name 
                                                     # are clubbed to make a string, which should be unique.

    uniqueOut = open(outname, 'w')
    
    uniqueOut.write(firstline)


        
    for line in overLapFile:
        repGen = organizeRepeatGene(line)
        if repGen not in repGeneCombo:
            uniqueOut.write(line)
            repGeneCombo.add(repGen)
        
    uniqueOut.close()
    
    



def filter(readfile):
    file = open(readfile, 'rU')
    
    firstLine = file.readline()
    
    readF = firstLine.split()
    
    firstRead = readF[0]
    
    outname1 = readfile[:-4] + '_k1.map'  # this output filename indicates a read output file 
    #that would have been generated by bowtie in case the -k 1 flag was used to report alignments
    # which means only one of the many valid reported alignments are reported. 
    outname2 = readfile[:-4] + '_rep.map'
    outname3 = readfile[:-4] + '_repAll.map'
    mapk1 = open(outname1, 'w')
    mapk1.write(firstLine)
    
    maprep = open(outname2, 'w')
    maprepAll = open(outname3, 'w')
    readPrev = firstRead
    switch = True # this switch specifies whether the current line needs to be written to maprep
    
    repSwitch = True # this switch specifies whether the current line needs to be written to maprepAll
    
    prevline = ''
    
    
    for line in file:
        
        readCurrent = organize(line)
        
        if readCurrent != readPrev:
            mapk1.write(line)
            
            switch = False
            repSwitch = True
        
        elif readCurrent == readPrev:
            if repSwitch == True: # finding the second occurance of this read
                maprepAll.write(prevline) # if the read is encountered the second time, the first occurance is also written to the repAll.map file
                repSwitch = False
            maprepAll.write(line) # writing the current occurance of read to repAll
            if switch == False:
                maprep.write(prevline) # writing the first occurance of read to rep
                switch = True
        
        readPrev = readCurrent   # current read now becomes previous read for the next iteration
        prevline = line # storing the current line as prevline for the next iteration of line
            
    file.close()
    mapk1.close()
    maprep.close() 
    maprepAll.close()




def organize(string):
    
    list = string.split() # this splits the list on the basis of whitespace and returns individual words of the string as a list 
    readId = list[0]
    del list
    return readId

def organizeGene(string):
    splitline = string.split()
    geneName = splitline[9]
    return geneName
    
def organizeRepeatGene(string):
    splitline = string.split()
    repeatDetails = splitline[3].split('#')
    
    
    return repeatDetails[-1]+ splitline[9]
    
    
def organizeRepeat(string):
    splitline = string.split()
    repeatDetails = splitline[3].split('#')
    
    
    return repeatDetails[-1]
  

def main():
    overlapFile = sys.argv[1]
    filterOutDupV3(overlapFile)
    
if __name__=='__main__':
    main()